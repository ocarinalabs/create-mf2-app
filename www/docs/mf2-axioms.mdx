---
title: "MF2 Axioms"
description: "The principles that guide every decision in the MF2 stack"
icon: "compass"
---

# The MF2 Way

**For devs who want to ship fast.** We built MF2 because we were tired of spending weeks on setup instead of shipping features. These axioms guide every decision in the stack - they're why AI moves fast with MF2.

## Ship First, Perfect Later

**The first version is always wrong anyway.**

You know that perfect architecture you're designing? It won't survive contact with real users. That elegant abstraction? You'll rip it out in v2. That scalability concern? You'll pivot before it matters.

```tsx
// ❌ What most devs do
"Let me set up the perfect monorepo structure with..."
"I should probably abstract this in case we need..."
"What if we get 1 million users on day one..."

// ✅ The MF2 way
npx create-mf2-app@latest && npm run dev
// Start building your actual feature
```

We optimize for learning velocity, not hypothetical scale. Every MF2 decision asks: "Does this help ship v1 faster?"

## Every Decision Optimizes for Velocity

**Speed is the only sustainable competitive advantage.**

While your competitor debates PostgreSQL vs MongoDB, you've already launched. While they optimize their build process, you've already got user feedback. While they refactor for "clean code," you've already pivoted based on what you learned.

<AccordionGroup>
  <Accordion title="Why Convex over PostgreSQL?" icon="database">
    Setup time: 0 minutes vs 2 hours
    
    Real-time subscriptions: Built-in vs DIY
    
    Type safety: Automatic vs Prisma ceremony
    
    **You lose**: Some SQL features, vendor lock-in anxiety
    
    **You gain**: Shipping this week instead of next month
  </Accordion>
  
  <Accordion title="Why Clerk over NextAuth?" icon="lock">
    Working auth: 5 minutes vs 2 days
    
    User management UI: Included vs build yourself
    
    Social logins: One click vs one day each
    
    **You lose**: $25/month, some customization
    
    **You gain**: Actually having users to authenticate
  </Accordion>
  
  <Accordion title="Why Polar over Stripe?" icon="credit-card">
    Subscription setup: 10 minutes vs 2 weeks
    
    Customer portal: Automatic vs 1000 lines of code
    
    Analytics: Built-in vs Stripe + custom dashboards
    
    **You lose**: 1% higher fees, some edge cases
    
    **You gain**: Making money before your runway ends
  </Accordion>
</AccordionGroup>

## AI is Your Pair Programmer

**The stack AI moves fast with.**

MF2 is built with modern tools developers and LLMs love. Every pattern is optimized for AI comprehension. Explicit over clever. Standard over special. When Claude or Cursor sees MF2 code, it knows exactly what to do - because we use the patterns it's seen thousands of times.

```tsx
// ❌ Clever code that confuses AI
const enhancer = <T,>(fn: (args: T) => T) => 
  (args: T): T => fn({ ...args, enhanced: true });

// ✅ Explicit code that AI can extend
export async function createUser(data: { 
  email: string; 
  name: string; 
}) {
  const user = await db.user.create({ data });
  await sendWelcomeEmail(user.email);
  return user;
}
```

Your codebase should be so standard that Claude can add features while you sleep. (Not that you should, but you could.)

## Convention Over Configuration (Until It Hurts)

**Decisions, not options.**

Every configuration option is a decision you're forcing on developers. Every abstraction is complexity you're adding. Every "just in case" is time you're stealing from shipping.

<Note>
  **The MF2 Promise**: You won't touch a config file for your first 10 features. When you finally need to, it'll be for a real reason, not because someone thought you might maybe possibly need it someday.
</Note>

We configured everything. When our conventions finally break for your use case (they will eventually), *then* you customize. Not before.

## Your MVP Code IS Your Production Code

**Build it right the first time. Ship it anyway.**

This sounds contradictory. It's not. MF2 gives you production-grade infrastructure from day one. Real authentication. Real payments. Real data sync. You're not building a "throwaway prototype" - you're building v1 of your real product.

```tsx
// This "MVP" code is already:
// - Type-safe end-to-end
// - Authenticated properly  
// - Syncing in real-time
// - Ready for payments
// - Deployed globally

export const createProject = mutation({
  args: {
    name: v.string(),
    description: v.string(),
  },
  handler: async (ctx, args) => {
    const user = await ctx.auth.getUserIdentity();
    if (!user) throw new Error("Unauthorized");
    
    return await ctx.db.insert("projects", {
      ...args,
      userId: user.subject,
      createdAt: Date.now(),
    });
  },
});
```

The code you write on day 1 can scale to 100K users. Not because we premature-optimized, but because we chose boring, proven infrastructure.

## Strong Opinions, Loosely Held

**We're opinionated until you prove us wrong.**

Every MF2 choice is based on shipping real products. But your needs might be different. That's why every major component has an escape hatch:

- Don't like Convex? Here's how to swap in Supabase
- Need more than Clerk? Here's the Auth.js migration
- Outgrew Polar? Here's the Stripe upgrade path

We'll strongly recommend our way. We'll also show you the door if you need it.

## The Proof

These aren't theoretical principles. We've shipped:
- B2B SaaS that hit $10K MRR in 60 days
- Consumer apps with 50K users
- AI products that scaled to 1M requests/day
- Marketplace apps processing real money

All started with `npx create-mf2-app@latest`.

## Ready to Move Fast?

If you've read this far and you're nodding, welcome. You get it. Now stop reading manifestos and go build something.

<Card
  title="Your first app in 10 minutes"
  icon="rocket"
  href="/first-app"
  horizontal
>
  Philosophical alignment confirmed. Time to ship.
</Card>